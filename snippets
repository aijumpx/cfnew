import { connect } from 'cloudflare:sockets';

// --- é…ç½®åŒºåŸŸ ---
const CONFIG = {
  // ä½ çš„ UUID
  UUID: 'ec387f89-bb13-49c2-8d70-a7685c8ebb00', 
  
  // ä¼˜é€‰ IP è®¢é˜…åœ°å€
  GITHUB_IP_URL: 'https://raw.githubusercontent.com/qwer-search/bestip/refs/heads/main/kejilandbestip.txt',
  
  // è®¢é˜…è½¬æ¢åç«¯
  SUB_API: 'https://cf.maiship.com/sub',
  
  // å›ºå®šçš„ä¼˜é€‰åŸŸååˆ—è¡¨
  DIRECT_DOMAINS: [
    "cloudflare.182682.xyz", "speed.marisalnc.com", "freeyx.cloudflare88.eu.org", 
    "bestcf.top", "cdn.2020111.xyz", "cfip.cfcdn.vip", "cf.0sm.com", 
    "cf.090227.xyz", "cf.zhetengsha.eu.org", "cloudflare.9jy.cc", 
    "cf.zerone-cdn.pp.ua", "cfip.1323123.xyz", "cnamefuckxxs.yuchen.icu", 
    "cloudflare-ip.mofashi.ltd", "115155.xyz", "cname.xirancdn.us", 
    "f3058171cad.002404.xyz", "8.889288.xyz", "cdn.tzpro.xyz", 
    "cf.877771.xyz", "xn--b6gac.eu.org"
  ],

  // å¤‡ç”¨èŠ‚ç‚¹æ±  (æŒ‰åœ°åŒºåˆ†ç±»)
  BACKUP_IPS: [
    { domain: 'ProxyIP.US.CMLiussss.net', region: 'US', port: 443 },
    { domain: 'ProxyIP.SG.CMLiussss.net', region: 'SG', port: 443 },
    { domain: 'ProxyIP.JP.CMLiussss.net', region: 'JP', port: 443 },
    { domain: 'ProxyIP.HK.CMLiussss.net', region: 'HK', port: 443 },
    { domain: 'ProxyIP.KR.CMLiussss.net', region: 'KR', port: 443 },
    { domain: 'ProxyIP.DE.CMLiussss.net', region: 'DE', port: 443 },
    { domain: 'ProxyIP.GB.CMLiussss.net', region: 'GB', port: 443 }
  ]
};

// --- æ ¸å¿ƒé€»è¾‘ ---

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const upgradeHeader = request.headers.get('Upgrade');

      // 1. å¤„ç† VLESS WebSocket è¿æ¥
      if (upgradeHeader === 'websocket') {
        const fallback = await getBestFallback(request);
        return await handleWsRequest(request, fallback);
      }

      // 2. å¤„ç†è®¢é˜…è¯·æ±‚ /sub æˆ– /UUID
      const path = url.pathname;
      if (path.includes('/sub') || path.includes(CONFIG.UUID)) {
        return await handleSubscription(request, url);
      }

      // 3. é»˜è®¤è¿”å›ç®€æ˜“çš„è®¢é˜…é¡µé¢
      return handleHtmlPage(request);

    } catch (err) {
      return new Response(err.toString(), { status: 500 });
    }
  }
};

// --- è¾…åŠ©åŠŸèƒ½å‡½æ•° ---

// æ™ºèƒ½é€‰æ‹©æœ€è¿‘çš„èŠ‚ç‚¹
async function getBestFallback(request) {
  const cfCountry = request.cf?.country || 'HK';
  
  // ç®€å•çš„åœ°åŒºæ˜ å°„é€»è¾‘
  let targetRegion = 'HK';
  const regionMap = {
    'US': 'US', 'CA': 'US', 'BR': 'US',
    'SG': 'SG', 'MY': 'SG', 'TH': 'SG', 'AU': 'SG',
    'JP': 'JP', 
    'KR': 'KR',
    'DE': 'DE', 'FR': 'DE', 'NL': 'DE', 'RU': 'DE',
    'GB': 'GB', 'IE': 'GB'
  };
  
  if (regionMap[cfCountry]) targetRegion = regionMap[cfCountry];

  // æŸ¥æ‰¾åŒ¹é…çš„ IP
  const matchedIP = CONFIG.BACKUP_IPS.find(ip => ip.region === targetRegion);
  if (matchedIP) return `${matchedIP.domain}:${matchedIP.port}`;
  
  // å…œåº•
  return 'ProxyIP.HK.CMLiussss.net:443';
}

// ç”Ÿæˆç²¾ç®€ç‰ˆ HTML é¡µé¢ (ä»…ä¿ç•™ Clash)
function handleHtmlPage(request) {
  const html = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VLESS è®¢é˜…</title>
<style>
body{font-family:system-ui,-apple-system,sans-serif;background:#111;color:#eee;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}
.card{background:#222;padding:2rem;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.5);text-align:center;max-width:400px;width:100%}
h1{color:#4caf50;margin-bottom:1.5rem}
.btn{display:block;width:100%;padding:12px;margin:10px 0;background:#333;color:#fff;border:1px solid #444;border-radius:6px;cursor:pointer;transition:0.2s}
.btn:hover{background:#4caf50;border-color:#4caf50;color:#000}
.url-box{margin-top:20px;padding:10px;background:#000;border:1px dashed #555;font-family:monospace;font-size:12px;word-break:break-all;display:none;color:#aaa}
</style>
</head>
<body>
<div class="card">
  <h1>ğŸš€ æé€Ÿè®¢é˜…</h1>
  <button class="btn" onclick="copyClash()">å¤åˆ¶ Clash è®¢é˜…</button>
  <button class="btn" onclick="copyVless()">å¤åˆ¶ VLESS åŸç”Ÿé“¾æ¥</button>
  <div class="url-box" id="msg"></div>
</div>
<script>
  const subBase = window.location.origin + "/${CONFIG.UUID}";
  
  function copyText(text, type) {
    navigator.clipboard.writeText(text).then(() => {
      const msg = document.getElementById('msg');
      msg.style.display = 'block';
      msg.innerText = type + " å·²å¤åˆ¶åˆ°å‰ªè´´æ¿";
      setTimeout(() => msg.style.display = 'none', 3000);
    });
  }

  function copyClash() {
    const clashUrl = "${CONFIG.SUB_API}?target=clash&url=" + encodeURIComponent(subBase) + "&insert=false";
    copyText(clashUrl, 'Clash è®¢é˜…');
  }

  function copyVless() {
    fetch(subBase).then(r => r.text()).then(t => copyText(atob(t), 'èŠ‚ç‚¹é“¾æ¥'));
  }
</script>
</body>
</html>`;

  return new Response(html, { headers: { 'Content-Type': 'text/html; charset=utf-8' } });
}

// å¤„ç†è®¢é˜…å†…å®¹ç”Ÿæˆ
async function handleSubscription(request, url) {
  const workerDomain = url.hostname;
  let finalLinks = [];

  // 1. æ·»åŠ å½“å‰ Worker åŸŸåä½œä¸ºåŸç”ŸèŠ‚ç‚¹
  finalLinks.push(generateVlessLink(workerDomain, 443, "åŸç”ŸèŠ‚ç‚¹", workerDomain));

  // 2. æ·»åŠ ä¼˜é€‰åŸŸå
  CONFIG.DIRECT_DOMAINS.forEach(domain => {
    finalLinks.push(generateVlessLink(domain, 443, domain, workerDomain));
  });

  // 3. åŠ¨æ€è·å– GitHub ä¼˜é€‰ IP (å¦‚æœç½‘ç»œå…è®¸)
  try {
    const resp = await fetch(CONFIG.GITHUB_IP_URL);
    if (resp.ok) {
      const text = await resp.text();
      const lines = text.split('\n');
      const regex = /^([^:]+):(\d+)#(.*)$/;
      
      lines.forEach(line => {
        const match = line.trim().match(regex);
        if (match) {
          finalLinks.push(generateVlessLink(match[1], match[2], match[3], workerDomain));
        }
      });
    }
  } catch (e) { console.error('Failed to fetch Github IPs'); }

  // 4. å…œåº•å¤„ç†
  if (finalLinks.length === 0) {
    finalLinks.push(`vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F%3Fed%3D2048#Error`);
  }

  return new Response(btoa(finalLinks.join('\n')), {
    headers: { 'Content-Type': 'text/plain; charset=utf-8' }
  });
}

function generateVlessLink(addr, port, name, host) {
  const safeAddr = addr.includes(':') ? `[${addr}]` : addr;
  const params = `encryption=none&security=tls&sni=${host}&fp=randomized&type=ws&host=${host}&path=%2F%3Fed%3D2048`;
  return `vless://${CONFIG.UUID}@${safeAddr}:${port}?${params}#${encodeURIComponent(name)}`;
}

// --- WebSocket ä»£ç†æ ¸å¿ƒ (ä¼˜åŒ–ç‰ˆ) ---

async function handleWsRequest(request, fallbackAddr) {
  const { 0: client, 1: server } = new WebSocketPair();
  server.accept();

  let addressHeader = '';
  let portHeader = 0;
  let hasConnected = false;
  let remoteSocket = null;

  const readable = new ReadableStream({
    start(controller) {
      server.addEventListener('message', async (msg) => {
        const chunk = msg.data;
        
        // 1. å·²å»ºç«‹è¿æ¥ï¼Œç›´æ¥è½¬å‘
        if (hasConnected && remoteSocket) {
          const writer = remoteSocket.writable.getWriter();
          await writer.write(chunk);
          writer.releaseLock();
          return;
        }

        // 2. å¤„ç†é¦–åŒ… (VLESS Header è§£æ)
        const buffer = new Uint8Array(chunk); 
        
        try {
            const version = buffer[0];
            const optLen = buffer[17];
            const cmd = buffer[18 + optLen]; // 1=TCP, 2=UDP
            
            const portIndex = 19 + optLen;
            const port = (buffer[portIndex] << 8) | buffer[portIndex + 1];
            
            const addrType = buffer[portIndex + 2];
            let addrEnd = portIndex + 3;
            let address = '';

            if (addrType === 1) { // IPv4
                address = buffer.slice(addrEnd, addrEnd + 4).join('.');
                addrEnd += 4;
            } else if (addrType === 2) { // Domain
                const len = buffer[addrEnd];
                address = new TextDecoder().decode(buffer.slice(addrEnd + 1, addrEnd + 1 + len));
                addrEnd += 1 + len;
            } else if (addrType === 3) { // IPv6
                address = "ipv6-placeholder"; 
                addrEnd += 16;
            }

            // æ„å»ºå“åº”å¤´
            const responseHeader = new Uint8Array([version, 0]);
            
            // å‡†å¤‡å®é™…è½¬å‘çš„æ•°æ® (å»æ‰ VLESS å¤´)
            const rawData = buffer.slice(addrEnd);

            // å»ºç«‹è¿æ¥
            if (cmd === 2) { // UDP (DNS)
               // ç®€åŒ–ï¼šä»…è½¬å‘ 53 ç«¯å£çš„ UDP
               address = '8.8.8.8';
               portHeader = 53;
            } else {
               addressHeader = address;
               portHeader = port;
            }

            // æ‰§è¡Œè¿æ¥ (å¸¦ fallback)
            // ä¿®å¤ç‚¹: ç¡®ä¿ connect å‚æ•°æ°¸è¿œæ˜¯ string å’Œ numberï¼Œä¸ä¾èµ–éšå¼è½¬æ¢
            const targetHost = addressHeader || '1.1.1.1';
            const targetPort = portHeader || 80;

            try {
                remoteSocket = connect({ hostname: targetHost, port: targetPort });
            } catch {
                // è¿æ¥å¤±è´¥ï¼Œä½¿ç”¨ fallback
                // ä¿®å¤ç‚¹: ä¸¥æ ¼è§£æï¼Œå¤„ç† split å¯èƒ½å¸¦æ¥çš„ undefined
                const parts = fallbackAddr.split(':');
                const fbH = parts[0] || 'ProxyIP.HK.CMLiussss.net';
                const fbPStr = parts[1] || '443';
                remoteSocket = connect({ hostname: fbH, port: parseInt(fbPStr, 10) });
            }

            hasConnected = true;
            
            // å†™å…¥å‰©ä½™æ•°æ®
            const writer = remoteSocket.writable.getWriter();
            await writer.write(rawData);
            writer.releaseLock();

            // åŒå‘è½¬å‘
            remoteSocket.readable.pipeTo(new WritableStream({
                async write(v) {
                   if(server.readyState === 1) server.send(v);
                }
            })).catch(() => {});

            // å‘é€é¦–åŒ…å“åº”
            server.send(responseHeader);

        } catch (e) {
            console.log(e);
            server.close();
        }
      });
    }
  });

  return new Response(null, { status: 101, webSocket: client });
}
