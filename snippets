import { connect } from 'cloudflare:sockets';

const _K = {
    K1: "ZWMzODdmODktYmIxMy00OWMyLThkNzAtYTc2ODVjOGViYjAw",
    K2: "aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3F3ZXItc2VhcmNoL2Jlc3RpcC9yZWZzL2hlYWRzL21haW4va2VqaWxhbmRiZXN0aXAudHh0",
    K3: "aHR0cHM6Ly9jZi5tYWlzaGlwLmNvbS9zdWI=",
    D_LIST: "WyJjbG91ZGZsYXJlLjE4MjY4Mi54eXoiLCJzcGVlZC5tYXJpc2FsbmMuY29tIiwiZnJlZXl4LmNsb3VkZmxhcmU4OC5ldS5vcmciLCJiZXN0Y2YudG9wIiwiY2RuLjIwMjAxMTEueHl6IiwiY2ZpcC5jZmNkbi52aXAiLCJjZi4wc20uY29tIiwiY2YuMDkwMjI3Lnh5eiIsImNmLnpoZXRlbmdzaGEuZXUub3JnIiwiY2xvdWRmbGFyZS45ankuY2MiLCJjZi56ZXJvbmUtY2RuLnBwLnVhIiwiY2ZpcC4xMzIzMTIzLnh5eiIsImNuYW1lZnVja3h4cy55dWNoZW4uaWN1IiwiY2xvdWRmbGFyZS1pcC5tb2Zhc2hpLmx0ZCIsIjExNTE1NS54eXoiLCJjbmFtZS54aXJhbmNkbi51cyIsImYzMDU4MTcxY2FkLjAwMjQwNC54eXoiLCI4Ljg4OTI4OC54eXoiLCJjZG4udHpwcm8ueHl6IiwiY2YuODc3NzcxLnh5eiIsInhuLS1iNmdhYy5ldS5vcmciXQ==",
    B_LIST: "W3siZG9tYWluIjoiUHJveHlJUC5VUy5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiVVMiLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5TRy5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiU0ciLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5KUC5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiSlAiLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5ISy5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiSEsiLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5LUi5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiS1IiLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5ERS5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiREUiLCJwb3J0Ijo0NDN9LHsiZG9tYWluIjoiUHJveHlJUC5HQi5DTUxpdXNzc3MubmV0IiwicmVnaW9uIjoiR0IiLCJwb3J0Ijo0NDN9XQ=="
};

const _U = {
    d: (s) => { try { return atob(s); } catch { return ""; } },
    j: (s) => { try { return JSON.parse(atob(s)); } catch { return []; } },
    u: () => _U.d(_K.K1),
    g: () => _U.d(_K.K2),
    s: () => _U.d(_K.K3)
};

const _Geo = {
    detect: (req) => {
        try {
            const c = req.cf?.country;
            if (!c) return 'HK';
            const m = { 'US': 'US', 'CA': 'US', 'SG': 'SG', 'TH': 'SG', 'MY': 'SG', 'JP': 'JP', 'KR': 'KR', 'DE': 'DE', 'FR': 'DE', 'NL': 'DE', 'GB': 'GB', 'CN': 'HK' };
            return m[c] || 'HK';
        } catch { return 'HK'; }
    },
    getBest: (region) => {
        const pool = _U.j(_K.B_LIST);
        if (!pool.length) return null;
        const target = _Geo.map(region);
        const match = pool.find(i => i.region === target);
        return match ? `${match.domain}:${match.port}` : `${pool[0].domain}:${pool[0].port}`;
    },
    map: (r) => {
        const near = { 'US': 'US', 'SG': 'SG', 'JP': 'JP', 'HK': 'HK', 'KR': 'KR', 'DE': 'DE', 'GB': 'GB' };
        return near[r] || 'HK';
    }
};

const _P = {
    parse: (chunk, token) => {
        if (chunk.byteLength < 24) return { err: _U.d('aW52YWxpZCBkYXRh') };
        const v = new Uint8Array(chunk.slice(0, 1));
        if (_P.fmtId(new Uint8Array(chunk.slice(1, 17))) !== token) return { err: _U.d('aW52YWxpZCB1c2Vy') };
        
        const optLen = new Uint8Array(chunk.slice(17, 18))[0];
        const cmd = new Uint8Array(chunk.slice(18 + optLen, 19 + optLen))[0];
        const isUDP = cmd === 2;
        if (cmd !== 1 && cmd !== 2) return { err: _U.d('Y29tbWFuZCBpcyBub3Qgc3VwcG9ydGVk') };

        const pIdx = 19 + optLen;
        const port = new DataView(chunk.slice(pIdx, pIdx + 2)).getUint16(0);
        const aType = new Uint8Array(chunk.slice(pIdx + 2, pIdx + 3))[0];
        
        let aIdx = pIdx + 3;
        let host = '';
        let rawIdx = 0;

        if (aType === 1) {
            host = new Uint8Array(chunk.slice(aIdx, aIdx + 4)).join('.');
            rawIdx = aIdx + 4;
        } else if (aType === 2) {
            const len = new Uint8Array(chunk.slice(aIdx, aIdx + 1))[0];
            aIdx += 1;
            host = new TextDecoder().decode(chunk.slice(aIdx, aIdx + len));
            rawIdx = aIdx + len;
        } else if (aType === 3) {
            const p = [];
            const v6 = new DataView(chunk.slice(aIdx, aIdx + 16));
            for (let i = 0; i < 8; i++) p.push(v6.getUint16(i * 2).toString(16));
            host = p.join(':');
            rawIdx = aIdx + 16;
        } else {
            return { err: _U.d('aW52YWxpZCBhZGRyZXNzVHlwZQ==') };
        }

        return { err: null, type: aType, port, host, isUDP, idx: rawIdx, ver: v };
    },
    fmtId: (arr) => {
        const t = Array.from({ length: 256 }, (v, i) => (i + 256).toString(16).slice(1));
        return (t[arr[0]] + t[arr[1]] + t[arr[2]] + t[arr[3]] + "-" + t[arr[4]] + t[arr[5]] + "-" + t[arr[6]] + t[arr[7]] + "-" + t[arr[8]] + t[arr[9]] + "-" + t[arr[10]] + t[arr[11]] + t[arr[12]] + t[arr[13]] + t[arr[14]] + t[arr[15]]).toLowerCase();
    }
};

export default {
    async fetch(req, env, ctx) {
        try {
            const url = new URL(req.url);
            const upgrade = req.headers.get('Upgrade');
            const region = _Geo.detect(req);
            const fb = await _Geo.getBest(region);

            if (upgrade === 'websocket') {
                return await _Handler.ws(req, fb);
            }

            const path = url.pathname;
            const uuid = _U.u();
            if (path.includes('/sub') || path.includes(uuid)) {
                return await _Handler.sub(req, url, uuid);
            }

            return _Handler.page(req, uuid);
        } catch (e) {
            return new Response(e.toString(), { status: 500 });
        }
    }
};

const _Handler = {
    page: (req, uid) => {
        const html = `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Service</title><style>body{background:#000;color:#0f0;font-family:monospace;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh}button{background:#020;color:#0f0;border:1px solid #0f0;padding:10px 20px;margin:10px;cursor:pointer}</style></head><body><h1>STATUS: ONLINE</h1><button onclick="c('clash')">Clash</button><button onclick="c('vless')">VLESS</button><script>const u="${uid}";const b=window.location.origin+"/"+u;const a="${_U.s()}";function c(t){let x="";if(t==='clash')x=a+"?target=clash&url="+encodeURIComponent(b)+"&insert=false";else return fetch(b).then(r=>r.text()).then(t=>n(atob(t)));n(x)}function n(t){navigator.clipboard.writeText(t).then(()=>alert('Copied!'));}</script></body></html>`;
        return new Response(html, { headers: { 'Content-Type': 'text/html; charset=utf-8' } });
    },

    sub: async (req, url, uid) => {
        const host = url.hostname;
        const links = [];
        const push = (addr, port, name) => {
            const sAddr = addr.includes(':') ? `[${addr}]` : addr;
            links.push(`vless://${uid}@${sAddr}:${port}?encryption=none&security=tls&sni=${host}&fp=randomized&type=ws&host=${host}&path=%2F%3Fed%3D2048#${encodeURIComponent(name)}`);
        };

        push(host, 443, "原生节点");

        const domains = _U.j(_K.D_LIST);
        domains.forEach(d => {
            const dn = typeof d === 'string' ? d : d.domain;
            push(dn, 443, dn);
        });

        try {
            const r = await fetch(_U.g());
            if (r.ok) {
                const t = await r.text();
                t.split('\n').forEach(l => {
                    const m = l.trim().match(/^([^:]+):(\d+)#(.*)$/);
                    if (m) push(m[1], m[2], m[3] || m[1]);
                });
            }
        } catch {}

        if (!links.length) links.push(`vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F#Error`);

        return new Response(btoa(links.join('\n')), { headers: { 'Content-Type': 'text/plain; charset=utf-8' } });
    },

    ws: async (req, fallback) => {
        const { 0: client, 1: server } = new WebSocketPair();
        server.accept();
        
        let rSocket = null;
        let isDns = false;
        const ed = req.headers.get('sec-websocket-protocol') || '';

        const readable = new ReadableStream({
            start(ctrl) {
                server.addEventListener('message', e => { if(server.readyState===1) ctrl.enqueue(e.data); });
                server.addEventListener('close', () => ctrl.close());
                server.addEventListener('error', e => ctrl.error(e));
                if (ed) {
                    try { 
                        const b = atob(ed.replace(/-/g, '+').replace(/_/g, '/'));
                        const a = Uint8Array.from(b, c => c.charCodeAt(0));
                        ctrl.enqueue(a.buffer);
                    } catch {} 
                }
            }
        });

        readable.pipeTo(new WritableStream({
            async write(chunk) {
                if (isDns) return _Handler.fwdUdp(chunk, server);
                
                if (rSocket) {
                    const w = rSocket.writable.getWriter();
                    await w.write(chunk);
                    w.releaseLock();
                    return;
                }

                const res = _P.parse(chunk, _U.u());
                if (res.err) return server.close();

                if (res.isUDP) {
                    if (res.port === 53) isDns = true;
                    else return server.close(); 
                }

                const respHeader = new Uint8Array([res.ver[0], 0]);
                const payload = chunk.slice(res.idx);

                if (isDns) return _Handler.fwdUdp(payload, server, respHeader);

                await _Handler.connTcp(res.type, res.host, res.port, payload, server, respHeader, (s) => rSocket = s, fallback);
            }
        })).catch(() => {});

        return new Response(null, { status: 101, webSocket: client });
    },

    connTcp: async (type, host, port, payload, ws, head, setSock, fb) => {
        const doConn = async (h, p) => {
            const pp = parseInt(String(p), 10);
            const s = connect({ hostname: h, port: pp });
            const w = s.writable.getWriter();
            await w.write(payload);
            w.releaseLock();
            return s;
        };

        const pipe = (remote, header) => {
            setSock(remote);
            remote.readable.pipeTo(new WritableStream({
                async write(v) {
                    if (ws.readyState === 1) {
                        if (header) {
                            ws.send(await new Blob([header, v]).arrayBuffer());
                            header = null;
                        } else {
                            ws.send(v);
                        }
                    }
                }
            })).catch(() => {});
        };

        try {
            const s = await doConn(host, port);
            pipe(s, head);
        } catch {
            try {
                const parts = fb.split(':');
                const fbH = parts[0] || host;
                const fbP = parts[1] || port;
                const s = await doConn(fbH, fbP);
                pipe(s, head);
            } catch {}
        }
    },

    fwdUdp: async (chunk, ws, head) => {
        try {
            const s = connect({ hostname: '8.8.4.4', port: 53 });
            const w = s.writable.getWriter();
            await w.write(chunk);
            w.releaseLock();
            
            let h = head;
            s.readable.pipeTo(new WritableStream({
                async write(v) {
                    if (ws.readyState === 1) {
                        if (h) {
                            ws.send(await new Blob([h, v]).arrayBuffer());
                            h = null;
                        } else {
                            ws.send(v);
                        }
                    }
                }
            }));
        } catch {}
    }
};
